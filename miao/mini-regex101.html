<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>regex101</title>
    <link rel="shortcut icon" href="../images/oogi2.ico" type="image/x-icon">
    <style>
        * {
            /* padding: 0; */
            /* margin: 0; */
        }
        
        em {
            font-style: normal;
            background-color: #9fcfff;
        }
        
        em:nth-of-type(even) {
            background-color: #D5EBFF;
        }
        /* 利用:empty伪元素设置零宽断言的em，因为字号继承原因em是有高度的 */
        
        em:empty {
            border-right: 1px dotted red;
            background-color: transparent;
            margin-left: -1px;
        }
        
        .regex101 {
            margin-left: 50px;
            margin-top: 50px;
        }
        
        input[type='text'],
        textarea {
            width: 300px;
            outline: none;
            /* font-family: consolas; */
        }
        
        pre {
            font-family: monospace;
        }
        
        input {
            border: 1px solid rgb(118, 118, 118);
            height: 1.4em;
        }
        
        label {
            font-family: consolas;
            /* font-family: monospace; */
            cursor: pointer;
        }
        
        label input {
            cursor: pointer;
        }
        /* textarea与pre的重叠 */
        
        section {
            width: 300px;
            position: relative;
            font-family: consolas;
            margin-top: .8em;
            overflow: hidden;
        }
        
        section textarea,
        section pre {
            /* textarea是行内块元素，默认底部|最后一行对齐匿名文本基线 */
            display: block;
            padding: 5px;
            border: 1px solid rgb(118, 118, 118);
            margin: 0;
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            font-family: consolas;
            font-size: 16px;
            /* 设置折行一致 */
            white-space: pre-wrap;
            word-break: break-all;
            /* 避免因输入字很多而宽度不一致 */
            overflow-y: scroll;
        }
        
        section textarea {
            background: transparent;
        }
        
        section pre {
            position: absolute;
            z-index: -1;
            top: 0px;
            left: 0px;
            color: transparent;
            /* font: 400 13.3333px Arial */
            overflow-x: hidden;
            border-color: transparent;
        }
        /* 报错 */
        
        #regError {
            color: red;
            margin: 0;
            height: 1em;
        }
    </style>
</head>

<body>
    <div class="regex101">
        请输入正则表达式：
        <label><input type="checkbox" name="" id="global" checked onclick="run()"> g </label>
        <label><input type="checkbox" name="" id="ignoreCase" onclick="run()"> i</label>
        <label><input type="checkbox" name="" id="multiLine" onclick="run()"> m</label>
        <br>
        <!-- onkeydown（11年来）都是读的旧的内容，然后新内容被键入-->
        <!-- 而oninput就是总是等新内容键入后再执行该事件 -->
        <input type="text" name="" id="reg" oninput="run()" value=""> <br> 请输入内容：
        <br>
        <p id="regError"></p>
        <section>
            <textarea spellcheck="false" onscroll="setScroll()" id="strInput" cols="30" rows="10" oninput="run()">foobarbaz
        dqdiojqoxq
      jqoifja
    wqjdoiqjefoo fobfoa foc2wfoz19e9180
  wfooo dqw0921jdojfooqw9barar</textarea>
            <pre id="result"></pre>
        </section>
    </div>


    <script>
        function run() {
            console.time('run')
            var regSource = reg.value
            var flags = getFlags()
            if (regSource === '') { //正则为空，即/(?:)/，pre置''，p#regError用作提示
                result.innerHTML = ''
                regError.innerHTML = 'Please enter any key for  regular expression.'
                return
            }
            try {
                var re = new RegExp(regSource, flags) //注意不要起名叫reg，因为会跟上面id=reg的input全局变量重名，变量提升后reg.value就变成了undefined.value了
                regError.innerHTML = '' //能走到这说明没出错，清空p标签的内容
            } catch (e) { //捕捉由于/][/、/fo(/类似的语法错误。因为在正则拼写未完成的时候，run()也依然输入一个字符就执行一次
                if (e instanceof SyntaxError) {
                    regError.innerHTML = e.message
                } else {
                    console.log('有其他非正则拼写错误！请回顾代码！错误信息：', e.message)
                    console.dir(e)
                }
                resultHTML = '' //不匹配任何内容直接返回
                return -1 //出错return -1
            }
            // console.log(re)
            var str = strInput.value
            var match
            var resultHTML = ''
            if (re.global) {
                //将匹配到的单词，用<em></em>包起来。对于匹配到的前面的单词，需要直接拼起来
                var lastIndex = re.lastIndex //记录lastIndex，从0开始。因为resultHTML都要从上一次匹配完成的位置+1开始截取str
                while (match = re.exec(str)) {
                    //每次截取，能够得到被截取的字符串match[0]和其在原父串里的位置为[match.index,re.lastIndex)；对于匹配的前面的字符串，范围自然是上一次的re.lastIndex到这次的match.index
                    resultHTML += str.slice(lastIndex, match.index) + '<em>' + match[0] + '</em>';
                    //对于**所有且仅是**的零宽断言来说，都会匹配空串，且剩余部分仍有可能匹配该零宽断言，re.lastIndex应当+1以试图继续匹配。先加还是后加：选特殊值^匹配的是str[0]左侧的空隙，但re.lastIndex仍是0，当++以试图寻找新的空隙匹配，lastIndex只影响每轮截取的匹配字段前面的字段长度，匹配到空隙时，lastIndex仍应从上次匹配空隙后面的元素开始算起，所以直接赋值re.lastIndex
                    lastIndex = re.lastIndex //当下一轮match===null时，lastIndex仍记得上一次的re.lastIndex
                    if (match[0] === '') {
                        re.lastIndex++
                    }
                }
                resultHTML += str.slice(lastIndex)
            } else { //no global
                match = re.exec(str)
                if (match) {
                    resultHTML = str.slice(0, match.index) + '<em>' + match[0] + '</em>' + str.slice(match.index + match[0].length) //由于re没有g标志，所以re.lastIndex总为0
                }
            }
            result.innerHTML = resultHTML //赋给#result的<pre>
            console.timeEnd('run')
        }

        //即使我们不与#reg交互，也想要run()运行一次。刷新页面如有缓存也有效
        run();
        //拿到被选中的checkBox，返回flags作为re.flags
        function getFlags() {
            var flags = ''
            if (global.checked) {
                flags += 'g'
            }
            if (ignoreCase.checked) {
                flags += 'i'
            }
            if (multiLine.checked) {
                flags += 'm'
            }
            return flags
        }

        //当textarea进行onScroll事件时，pre标签同时也需要滚动
        function setScroll() {
            result.scrollTop = strInput.scrollTop //两个滚动一致
                // result.style.top = -scrollTop + 'px'
        }
    </script>
</body>

</html>